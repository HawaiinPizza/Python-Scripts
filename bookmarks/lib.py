
# Parsing functions
from os.path import basename, abspath

class alias:
    """ Using the power of inheritence, this will be used to generate
        alias generator. It has three functions: the pre-hook, the
        post-hook, and the acutal aliasing. THis is so shit like 
        emacs's bookmarks, which require a beginning ( and a closing
        ) can be done
    """
    def __init__(self, path):
        self.path = path

    def prehook(self):
        return None

    def aliaser(self, abbr, path, command):
        raise ValueError("Alias hasn't been generated.")

    def posthook(self):
        return None
    def spliter(self, line):
        try:
            if(line==None):
                return None
            split=(line.split(",",2))
            if(split[0] == "" or split[1]==""):
                return None
            ret=[]
            for i in split:
                ret.append(i.lstrip())
            return ret
        except:
            print(line)
            raise IndexError(self.path, line)

        return split
    def transform(self, line):
        """REGEX transform a line. Basically, just removes comments or if it's emptyline then remove it"""
        transform = line.split("#",1)[0]
        if(transform.isspace() or transform==""):
            return None
        return transform


    def write(self, lines):
        pre = self.prehook()
        post = self.posthook()
        writefile  = open(self.path, "w+")
        if(pre != None):
            writefile.write(pre+"\n")
        results = []
        for line in lines:
            split=self.spliter(self.transform(line))
            if(split != None):
                results.append(self.aliaser(*split)+"\n")
        results = set(results)
        list(map(lambda i: writefile.write(i), results))
        if(post != None):
            writefile.write(post)
        writefile.close()


class zsh(alias):
    def prehook(self):
        return """# Automaticly generated alias zsh file"""
    def aliaser(self, abbr, path, command=""):
        if(command == "x"):
            return  f'alias -g "{abbr}=setsid $OPEN \'{path}\'  2>/dev/null 1>&2 "'
        if(command == "e"):
            return   f'alias -g "{abbr}=$EDITOR \'{path}\'"'
        if(command == "xx"):
            return   f'alias -g "{abbr}=devour $OPEN \'{path}\'  2>/dev/null 1>&2 "'
        if(command == "fz"):
            return  """{0}()[
        pushd {1} 
        ($EDITOR "$(ls | fzy)" && cd {1}) || popd
]""".format(abbr, path).replace("[","{").replace("]","}")
        if(command == ""):
            return   f'alias -g "{abbr}=\'{path}\'"'

        else:
            raise KeyError(f"Command {command} not listed for  {abbr} {command} {path}")

class emacs(alias):
    def prehook(self):
        return """;;;; Emacs Bookmark Format Version 1;;;; -*- coding: utf-8-emacs; mode: lisp-data -*-
;;; This format is meant to be slightly human-readable;
;;; nevertheless, you probably don't want to edit it.
;;; -*- End Of Bookmark File Format Version Stamp -*-
;;; Autogenerated by zak, have fun with this scirpt
("""
        # return """; This is automaticly generated bookmarks file. DOn't edit it by human hands plz

    def aliaser(self, abbr, path, command=""):
        return  f'("{abbr}" (filename . "{path}"))' 

    def posthook(self):
        return ")"


class dmenufmBook(alias):
    def aliaser(self, abbr, path, command=""):
        if(path[-1]=="/"):
            path=path[0:-1]
        return   f'{basename(path)} - {path}'

class dmenufm(alias):
    def aliaser(self, abbr, path, command=""):
        if(command == "x" or command=="xx"):
            return  f'{abbr}:$OPEN "{path}"'
        if(command == "e"):
            return  f'{abbr}:st -e "{path}"'
        if(command == "fz"):
            return  f'{abbr}:cd {path} && dmenufm'
        if(command == ""):
            return  f'{abbr}:urxvtq "{path}"'

        else:
            raise KeyError(f"Command {command} not listed for  {abbr} {command} {path}")
class fzf(alias):
    def aliaser(self, abbr, path, command=""):
        if(command == "x"):
            return f'setsid $OPEN "{path}" 2>/dev/null 1>&2'
        if(command == "e"):
            return f'$EDITOR "{path}" '
        if(command == "xx"):
            return f'devour $OPEN "{path}" 2>/dev/null 1>&2'
        if(command == "" or command=="fz"):
            return   f'cd {path}'

        else:
            raise KeyError(f"Command {command} not listed for  {abbr} {command} {path}")
